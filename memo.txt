# 本
食べる！SSL！　―HTTPS環境構築から始めるSSL入門
https://www.amazon.co.jp/%E9%A3%9F%E3%81%B9%E3%82%8B%EF%BC%81SSL%EF%BC%81-%E2%80%95HTTPS%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8BSSL%E5%85%A5%E9%96%80-%E5%B0%8F%E5%B3%B6-%E6%8B%93%E4%B9%9F-ebook/dp/B00PHC4480

# CIAという三要素
・機密性：Confidentiality
    意図した相手との通信が達成できているか、その通信が漏洩していないかどうかを示す。
    盗聴、なりすまし、内部からの情報漏えいがこの機密性を脅かす攻撃手段として存在する。
    受信者・送信者の認証

・完全性：Integrity
    通信した情報が誰にも改ざんされていないことを示す。
    機密性が担保されていたとしても、データが改竄されていれば意味が無い。
    
・可用性：Availability
    なにかのアクシデントがあったとしても、システムが動き続けること、使用できること。
    一見セキュリティには無関係に思われるが、DoS攻撃で可用性を脅かすこともセキュリティとしての驚異と言えるため。

# SSLが提供する3つの機能

1. ハイブリッド暗号方式による情報内容の暗号化
    サービサーは暗号化するための公開鍵を利用者に予め配布しておく。
    公開鍵を使って、共通鍵を取得する。このプロセスは公開鍵方式で行われる。
    利用者はその共通鍵を用いて、暗号化を行い、さらに共通鍵を公開鍵で暗号化し、通信を行う。これは共通鍵方式を用いて行われる。
    サービサーは秘密鍵を使って、共通鍵を取り出す。さらにその共通鍵で受信した暗号化文字列を復号化する。

2. MAC関数による改ざんの検知
    データとMAC値を比較し、改ざんされていないことを保証する。
    データと共通鍵を用いて、MAC値を生成する。

3. デジタル署名
    サービサーは自身の秘密鍵を使って、相手にデータを送信する。そのデータはサービサーの公開鍵を持っていれば、誰でも復号化が可能だが、サービサーのものであることを特定できる。
    
# SSL 通信の仕組み・範囲

SSL通信の流れは2つのフェーズで構成される。
・前半がハンドシェイクフェーズ
・後半がデータ転送フェーズ

SSLはハイブリッド暗号方式であるため、公開鍵暗号方式で共通鍵を交換するのが前半のハンドシェイクフェーズ
共通鍵暗号方式で実施するのがデータ転送となる

## ハンドシェイクフェーズ
1. 使用するアルゴリズムの合意
    クライアントが対応可能なアルゴリズムのリストをサーバーに送付する。
    （疑問：これはCData Driverが設定している？）
    ・SSLのバージョン
        https://kinsta.com/jp/knowledgebase/tls-vs-ssl/
        SSL 1.0：キュリティホールのためにリリースされませんでした。
        SSL 2.0：1995年にリリース。2011年に廃止。既知のセキュリティホールがあります。
        SSL 3.0：1996年にリリース。2015年に廃止。既知のセキュリティホールがあります。
        TLS 1.0：1999年にSSL 3.0のアップグレードとしてリリース。2020年に廃止予定。
        TLS 1.1：2006年にリリース。2020年に廃止予定。
        TLS 1.2：2008年にリリース。
        TLS 1.3：2018年にリリース。

    ・サーバー認証アルゴリズム
    ・鍵交換アルゴリズム
    ・データ転送で使用するデータ保護用の共通鍵暗号方式アルゴリズム
    ・データ転送で使用するデータの完全性を確認するためのMACアルゴリズム
    ・圧縮アルゴリズム

2. サーバーの認証
    認証アルゴリズムの同意と同時に、自身の公開鍵を含む証明書を送付します。
    クライアントはサーバーの証明書を確認し、サーバーが正しいものであることを確認します。
    （疑問：この確認とは、自身の持っている証明書の一覧に符号するかどうかを確認？）


3. データ転送で使用する鍵の確立
    クライアントとサーバーは同じ鍵生成関数を用いて、ランダムな文字列から暗号化鍵とMAC鍵を生成する。
    あるランダムな文字列はクライアントで生成する。
    生成するにはサーバーの公開鍵を用いる。
    ただ、あるランダムな文字列のみ使用すると異なるセッションでも同じ鍵が作成されてしまうため、クライアントとサーバーそれぞれで予め乱数も作成しておく。
    この乱数はステップ1のアルゴリズムの同意のときにお互いに送付する。


4. ハンドシェイクが正しく行われたことの確認



